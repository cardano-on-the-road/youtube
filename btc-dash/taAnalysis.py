import pandas as pdimport numpy as npimport yfinance as yfimport datetime as dtimport matplotlib.dates as mpl_datesfrom ta import add_all_ta_featureslevels = []def isSupport(df,i):    support = df['Low'][i] < df['Low'][i-1]  and df['Low'][i] < df['Low'][i+1] \        and df['Low'][i+1] < df['Low'][i+2] and df['Low'][i-1] < df['Low'][i-2]    return supportdef isResistance(df,i):    resistance = df['High'][i] > df['High'][i-1]  and df['High'][i] > df['High'][i+1] \        and df['High'][i+1] > df['High'][i+2] and df['High'][i-1] > df['High'][i-2]     return resistancedef isFarFromLevel(l, s):    return np.sum([abs(l-x) < s  for x in levels]) == 0def get_coordinates(tup, time_series):        points = tup[0]    values = tup[1]        x=[]    y=[]    for i in points:        x.append(time_series.index[i])        y.append(i*values[0]+values[1])    return x, y   def get_coordinates_tuples(trend, time_series):    buffer = []    ris = []    i = 0    for t in trend:        if i>=3:            break        x, y = get_coordinates(t, time_series)        if isFarFromLine(np.sum(np.array(t[0])), buffer):            ris.append((x, y))            i = i+1    return ris        def isFarFromLine(el, buffer):    for i in buffer:        if abs(el - i)/el * 100 < 15:            return False    buffer.append(el)    return Trueclass taAnalysis:        def __init__(self, asset, start_date, start_plot_date, end_date = dt.date.today() ,end_plot_date = dt.date.today()):        self.asset = asset        self.start_plot_date = start_plot_date        self.end_plot_date = end_plot_date        self.end_date = end_date        self.start_date = start_date        self.levels = []            def download_data(self):        downloaded_data = yf.download(self.asset, start=self.start_date, end=self.end_date)        df = downloaded_data.copy()        df['Date'] = pd.to_datetime(df.index)        df['Date'] = df['Date'].apply(mpl_dates.date2num)        df = df.loc[:,['Date', 'Open', 'High', 'Low', 'Close', 'Volume']]        df['Ma21'] = df['Close'].rolling(21).mean()        df['Ma50'] = df['Close'].rolling(50).mean()        df['Ma200'] = df['Close'].rolling(200).mean()        df['Volume_mean'] = df['Volume'].rolling(30).mean()        df.dropna(inplace=True)        df = add_all_ta_features(            df, open="Open", high="High", low="Low", close="Close", volume="Volume")        self.df = df            def get_data(self):        return self.df        def set_levels(self):        s =  np.mean(self.df['High'] - self.df['Low'])*2         for i in range(2,self.df.shape[0]-2):            if isSupport(self.df,i):                l = self.df['Low'][i]                        if isFarFromLevel(l, s):                    levels.append((i,l))                    elif isResistance(self.df,i):                l = self.df['High'][i]                        if isFarFromLevel(l, s):                    levels.append((i,l))            def plot_all(self):        print(levels)    if __name__ == "__main__":    ta = taAnalysis("btc", "2020-01-01", "2020-01-01")    ta.download_data()    ta.set_levels()    #df = ta.get_data()    ta.plot_all()            